---
title: Modelling Item Worth Based on Rankings
author: |
 | <br>**Heather Turner**, Freelance/University of Warwick, UK <br>
 | Jacob van Etten, Bioversity International, Costa Rica <br>
 | David Firth, University of Warwick/Alan Turing Institute, UK <br>
 | Ioannis Kosmidis, University of Warwick/Alan Turing Institute, UK <br><br>
date: May 15 2018
output: 
  revealjs::revealjs_presentation:
    keep_md: true
    theme: white
    transition : none
    css: custom.css
    slide_level: 1
    self_contained: false
    reveal_plugins: ["zoom", "notes", "menu"]
    reveal_options:
      menu:
        numbers: false
        themes: true
---


```{r setup, include=FALSE}
options(digits = 4)
options(width = 67)
library(knitr)
opts_chunk$set(echo = TRUE, dev = "png", dpi = 300,
               comment = "#")
# add \ after markdown img link so alt text not shown as caption
knit_hooks$set(plot = function(x, options) {
    cap <- options$fig.cap
    base <- opts_knit$get("base.url")
    if (is.null(base)) base <- ""
    sprintf("![%s](%s%s) \\", cap, base,
            opts_knit$get("upload.fun")(x))
}) 
# trim white space top and right of plot
knit_hooks$set(small.mar = function(before, options, envir) {
    if (before) par(mar = c(4, 8, .1, 4))
})
```

# Rankings

Rankings arise in a number of settings

 - Finishing order in a set of races
 - Consumer preferences in market research
 
What is the worth of each item?

---

# Luce's Axiom

> Probability of choosing item A over item B unaffected by other items 

Suppose we have a set of $J$ items

$$S = \{i_1, i_2, \ldots, i_J\}$$

Then under Luce's axiom

$$P(j | S) = \frac{\alpha_{j}}{\sum_{i \in S} \alpha_i}$$

where $\alpha_i$ represents the **worth** of item $i$.

---

# Plackett-Luce Model

Consider a ranking of $J$ items as a sequence of choices.

The *Plackett-Luce* model is then

$$P(i_1 \succ \ldots \succ i_J) = \prod_{j=1}^J\frac{\alpha_{i_j}}{\sum_{i \in A_j} \alpha_i}$$

where $A_j$ is the set of alternatives in choice $j$.

**PlackettLuce** can be used to fit this model.

---

# Example 1: Netflix Data

Netflix released movie rankings for the Netflix Prize.

Using `read.soc` from **PlackettLuce**, we read in a set of 
rankings for 4 movies

```{r}
library(PlackettLuce)
preflib <- "http://www.preflib.org/data/election/"
netflix <- read.soc(file.path(preflib,
                              "netflix/ED-00004-00000138.soc"))
head(netflix, 2)
```

---

## Convert to Rankings

**PlackettLuce** requires the rankings to give the rank per item 
vs. item per rank.

We convert the rankings using `as.rankings`, which creates a 
special data structure

```{r}
R <- as.rankings(netflix[,-1], input = "ordering")
colnames(R) <- attr(netflix, "item")
print(R[1:3], width = 60)
```

---

## Fit Plackett-Luce Model

Now `PlackettLuce` can be used to fit the model, with frequencies 
as weights

```{r}
mod <- PlackettLuce(R, weights = netflix$n)
coef(mod, log = FALSE)
```

These coefficients are the *worth* parameters and represent the 
probability that each movie is ranked first.

---

## Inference

For inference it is better to work on the log scale. Comparison intervals can be computed via `qvcalc`.

```{r qvcalc, fig.cap = "Plot of estimated log-worth for each movie, with 95% comparison interval. Beverly Hills Cop is significantly more popular than the other three movies, Mean Girls is significant more popular than The Mummy Returns or Mission: Impossible II, but there was no significant difference in usersâ€™ preference for these last two movies.", small.mar = TRUE, fig.width = 9.8, fig.height = 4}
qv <- qvcalc(mod)
plot(qv, ylab = "Worth (log)", main = NULL)
```

---

# Ranking properties

The Netflix rankings are an example of *strict*, *complete*
rankings.

In other applications we might have
 * tied ranks
 * incomplete rankings
     - *sub-rankings*: only some items ranked each time
     - *top-n*: only the top $n$ items are ranked
     
**PlackettLuce** implements a generalized model which handles 
ties and sub-rankings.

---

# Generalized Model

Now consider a ranking of sets $C_1 \succ C_2 \succ \ldots \succ C_J$.

The generalized model with ties up to order $D$ is

$$
\prod_{j = 1}^J \frac{f(C_j)}{
\sum_{k = 1}^{\min(D_j, D)} \sum_{S \in {A_j \choose k}} f(S)}
$$

where

$$f(S) = \delta_{|S|} \left(\prod_{i \in S} \alpha_i \right)^\frac{1}{|S|}$$

---

# Ranking Networks

In some cases, the underlying network of wins and losses means 
the worth cannot be estimated by maximum likelihood.

<div class="left">

```{r always-loses, message = FALSE, echo = FALSE, fig.width = 3.5, fig.height = 3.5, out.width = "300px", echo = FALSE, results = "asis", fig.cap = "Network in which one item always loses"}
par(mar = c(4, 2, 0, 2))
library(igraph)
R <- matrix(c(1, 2, 0, 0,
              2, 0, 1, 0,
              1, 0, 0, 2,
              2, 1, 0, 0,
              0, 1, 2, 0), byrow = TRUE, ncol = 4,
            dimnames = list(NULL, LETTERS[1:4]))
R <- as.rankings(R)
A <- adjacency(R)
net <- graph_from_adjacency_matrix(A)
plot(net, edge.arrow.size = 0.5, vertex.size = 30, frame = TRUE)
```

</div>

<div class="right">

```{r disconnected, message = FALSE, echo = FALSE, fig.width = 3.5, fig.height = 3.5, out.width = "300px", echo = FALSE, results = "asis", fig.cap = "Network with two separate groups of items, that are only observed to win or lose against other items in their group"}
par(mar = c(4, 2, 0, 2))
R <- matrix(c(1, 2, 0, 0, 0, 
              2, 0, 1, 0, 0,
              0, 1, 2, 0, 0,
              0, 0, 0, 1, 2,
              0, 0, 0, 2, 1), byrow = TRUE, ncol = 5,
            dimnames = list(NULL, LETTERS[1:5]))
R <- as.rankings(R)
A <- adjacency(R)
net <- graph_from_adjacency_matrix(A)
plot(net, edge.arrow.size = 0.5, vertex.size = 30,
     frame = TRUE)
```

</div>

---

# Pseudo-rankings

**PlackettLuce** connects the network by adding `npseudo` 
*pseudo-rankings* with a ghost item.

<div class="left">

- The MLE is always estimable
- Can be viewed as a Bayesian prior
- Default `nspeudo = 0.5`

</div>

<div class="right">

```{r pseudo-rankings, fig.width = 3.5, fig.height = 3.5, echo = FALSE, results = "asis", fig.cap = "Network with pseudo-rankings, in which each item wins and loses against ghost item"}
par(mar = c(4, 2, 0, 2))
R <- matrix(c(0, 0, 0, 1, 2,
              0, 0, 0, 2, 1,
              0, 0, 1, 0, 2,
              0, 0, 2, 0, 1,
              0, 1, 0, 0, 2,
              0, 2, 0, 0, 1,
              1, 0, 0, 0, 2,
              2, 0, 0, 0, 1,
              1, 2, 0, 0, 0,
              2, 0, 1, 0, 0,
              1, 0, 0, 2, 0,
              2, 1, 0, 0, 0,
              0, 1, 2, 0, 0), byrow = TRUE, ncol = 5,
            dimnames = list(NULL, c(LETTERS[1:4], "G")))
R <- as.rankings(R)
A <- adjacency(R)
net <- graph_from_adjacency_matrix(A)
V(net)$color <- c(rep("#E69F00", 4), "#84aae8")
plot(net, edge.arrow.size = 0.5, vertex.size = 30, frame = TRUE)
```

</div>

---

# Heterogeneity

The worth of items may vary with the ranking conditions, e.g. 
judge making the ranking.

**PlackettLuce** works with **partykit** to fit *Plackett-Luce trees*

1. Fit Plackett-Luce to all the data.
2. Test stability of worth parameters w.r.t. each covariate.
3. If significant instability, split data by relevant covariate.
4. Repeat 1-3 until no significant instability/split makes 
sub-group too small.

---

# Example 2: Beans

A citizen science trial of bean varieties in Nicaragua:

 - 11 bean varieties 
 - Each farmer grew 3 varieties
     - Asked which was best and which was worst
     - Asked to compare each to variety to local variety
 - Covariates on growing conditions, including
     - Growing season (Primera, Postrera, Apante)
     - Year
     - Maximum night-time temperature
     
---

## Example 2: Beans

The example on `?beans` tidies the original data
```{r}
example("beans", package = "PlackettLuce", echo = FALSE)
```

The original `beans` data frame has 842 rows: one per farm.

The 3-way and 2-way rankings are collated in a rankings object

```{r}
R[1,]
R[3368,]
```

---

## Plackett-Luce Tree

The rankings are grouped by farm

```{r}
G <- grouped_rankings(R, rep(1:nrow(beans), 4))
format(head(G, 2), width = 50)
```

A tree with max depth 3 and at least 5% records in each group

```{r, cache = TRUE}
beans$year <- factor(beans$year)
tree <- pltree(G ~ ., data = beans[c("season", "year", "maxTN")],
               minsize = 0.05*n, maxdepth = 3)
```

---

## Plotting Tree

```{r pltree, message = FALSE, fig.width = 10, echo = FALSE, fig.cap = "Item worth estimates within each node of the Plackett-Luce tree."}
plot(tree, names = FALSE, abbreviate = 2)
```

---

# Summary

Future work
 - Incorporating spatial effects
 - Incorporating genotype information
 
More details
 - **PlackettLuce** is on CRAN and GitHub
 - Full details of the methods and further examples in the vignette
